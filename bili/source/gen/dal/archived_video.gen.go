// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/alice52/archive/bili/source/gen/model"
)

func newArchivedVideo(db *gorm.DB, opts ...gen.DOOption) archivedVideo {
	_archivedVideo := archivedVideo{}

	_archivedVideo.archivedVideoDo.UseDB(db, opts...)
	_archivedVideo.archivedVideoDo.UseModel(&model.ArchivedVideo{})

	tableName := _archivedVideo.archivedVideoDo.TableName()
	_archivedVideo.ALL = field.NewAsterisk(tableName)
	_archivedVideo.ArchivedType = field.NewInt64(tableName, "archived_type")
	_archivedVideo.SyncStatus = field.NewInt64(tableName, "sync_status")
	_archivedVideo.SyncTime = field.NewTime(tableName, "sync_time")
	_archivedVideo.Bvid = field.NewString(tableName, "bvid")
	_archivedVideo.SeasonID = field.NewInt64(tableName, "season_id")
	_archivedVideo.CreateTime = field.NewTime(tableName, "create_time")
	_archivedVideo.UpdateTime = field.NewTime(tableName, "update_time")
	_archivedVideo.DeleteTime = field.NewField(tableName, "delete_time")
	_archivedVideo.Aid = field.NewInt64(tableName, "aid")
	_archivedVideo.Cid = field.NewInt64(tableName, "cid")
	_archivedVideo.Tid = field.NewInt64(tableName, "tid")
	_archivedVideo.Cover = field.NewString(tableName, "cover")
	_archivedVideo.Ctime = field.NewInt64(tableName, "ctime")
	_archivedVideo.Pubdate = field.NewInt64(tableName, "pubdate")
	_archivedVideo.Duration = field.NewInt64(tableName, "duration")
	_archivedVideo.Title = field.NewString(tableName, "title")
	_archivedVideo.Intro = field.NewString(tableName, "intro")
	_archivedVideo.UpperMid = field.NewInt64(tableName, "upper_mid")
	_archivedVideo.UpperName = field.NewString(tableName, "upper_name")
	_archivedVideo.FaceName = field.NewString(tableName, "face_name")
	_archivedVideo.StatView = field.NewInt64(tableName, "stat_view")
	_archivedVideo.StatDanmaku = field.NewInt64(tableName, "stat_danmaku")
	_archivedVideo.StatReply = field.NewInt64(tableName, "stat_reply")
	_archivedVideo.StatFavorite = field.NewInt64(tableName, "stat_favorite")
	_archivedVideo.StatCoin = field.NewInt64(tableName, "stat_coin")
	_archivedVideo.StatShare = field.NewInt64(tableName, "stat_share")
	_archivedVideo.StatLike = field.NewInt64(tableName, "stat_like")
	_archivedVideo.StatDislike = field.NewInt64(tableName, "stat_dislike")
	_archivedVideo.StatNowRank = field.NewInt64(tableName, "stat_now_rank")
	_archivedVideo.StatHisRank = field.NewInt64(tableName, "stat_his_rank")
	_archivedVideo.StatEvaluation = field.NewString(tableName, "stat_evaluation")
	_archivedVideo.StatVt = field.NewInt64(tableName, "stat_vt")
	_archivedVideo.HonorReply = field.NewString(tableName, "honor_reply")
	_archivedVideo.Resp = field.NewString(tableName, "resp")

	_archivedVideo.fillFieldMap()

	return _archivedVideo
}

// archivedVideo 视频信息
type archivedVideo struct {
	archivedVideoDo

	ALL            field.Asterisk
	ArchivedType   field.Int64 // 0: fav, 1: coin, 2: like, 3: view
	SyncStatus     field.Int64 // 0: 未同步, 1: 同步中, 2: 同步完成
	SyncTime       field.Time  // 同步时间
	Bvid           field.String
	SeasonID       field.Int64 // bili season_id
	CreateTime     field.Time
	UpdateTime     field.Time
	DeleteTime     field.Field
	Aid            field.Int64  // bili aid
	Cid            field.Int64  // bili cid
	Tid            field.Int64  // bili tid
	Cover          field.String // video cover
	Ctime          field.Int64  // video create time
	Pubdate        field.Int64  // video publish time
	Duration       field.Int64  // video duration
	Title          field.String // video title
	Intro          field.String // video intro
	UpperMid       field.Int64  // video upper mid
	UpperName      field.String // video upper name
	FaceName       field.String // video upper face
	StatView       field.Int64  // video view count
	StatDanmaku    field.Int64  // video danmaku count
	StatReply      field.Int64  // video reply count
	StatFavorite   field.Int64  // video favorite count
	StatCoin       field.Int64  // video coin count
	StatShare      field.Int64  // video share count
	StatLike       field.Int64  // video like count
	StatDislike    field.Int64  // video dislike count
	StatNowRank    field.Int64  // video now rank
	StatHisRank    field.Int64  // video history rank
	StatEvaluation field.String // video evaluation
	StatVt         field.Int64  // video vt
	HonorReply     field.String // video honor reply
	Resp           field.String

	fieldMap map[string]field.Expr
}

func (a archivedVideo) Table(newTableName string) *archivedVideo {
	a.archivedVideoDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a archivedVideo) As(alias string) *archivedVideo {
	a.archivedVideoDo.DO = *(a.archivedVideoDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *archivedVideo) updateTableName(table string) *archivedVideo {
	a.ALL = field.NewAsterisk(table)
	a.ArchivedType = field.NewInt64(table, "archived_type")
	a.SyncStatus = field.NewInt64(table, "sync_status")
	a.SyncTime = field.NewTime(table, "sync_time")
	a.Bvid = field.NewString(table, "bvid")
	a.SeasonID = field.NewInt64(table, "season_id")
	a.CreateTime = field.NewTime(table, "create_time")
	a.UpdateTime = field.NewTime(table, "update_time")
	a.DeleteTime = field.NewField(table, "delete_time")
	a.Aid = field.NewInt64(table, "aid")
	a.Cid = field.NewInt64(table, "cid")
	a.Tid = field.NewInt64(table, "tid")
	a.Cover = field.NewString(table, "cover")
	a.Ctime = field.NewInt64(table, "ctime")
	a.Pubdate = field.NewInt64(table, "pubdate")
	a.Duration = field.NewInt64(table, "duration")
	a.Title = field.NewString(table, "title")
	a.Intro = field.NewString(table, "intro")
	a.UpperMid = field.NewInt64(table, "upper_mid")
	a.UpperName = field.NewString(table, "upper_name")
	a.FaceName = field.NewString(table, "face_name")
	a.StatView = field.NewInt64(table, "stat_view")
	a.StatDanmaku = field.NewInt64(table, "stat_danmaku")
	a.StatReply = field.NewInt64(table, "stat_reply")
	a.StatFavorite = field.NewInt64(table, "stat_favorite")
	a.StatCoin = field.NewInt64(table, "stat_coin")
	a.StatShare = field.NewInt64(table, "stat_share")
	a.StatLike = field.NewInt64(table, "stat_like")
	a.StatDislike = field.NewInt64(table, "stat_dislike")
	a.StatNowRank = field.NewInt64(table, "stat_now_rank")
	a.StatHisRank = field.NewInt64(table, "stat_his_rank")
	a.StatEvaluation = field.NewString(table, "stat_evaluation")
	a.StatVt = field.NewInt64(table, "stat_vt")
	a.HonorReply = field.NewString(table, "honor_reply")
	a.Resp = field.NewString(table, "resp")

	a.fillFieldMap()

	return a
}

func (a *archivedVideo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *archivedVideo) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 34)
	a.fieldMap["archived_type"] = a.ArchivedType
	a.fieldMap["sync_status"] = a.SyncStatus
	a.fieldMap["sync_time"] = a.SyncTime
	a.fieldMap["bvid"] = a.Bvid
	a.fieldMap["season_id"] = a.SeasonID
	a.fieldMap["create_time"] = a.CreateTime
	a.fieldMap["update_time"] = a.UpdateTime
	a.fieldMap["delete_time"] = a.DeleteTime
	a.fieldMap["aid"] = a.Aid
	a.fieldMap["cid"] = a.Cid
	a.fieldMap["tid"] = a.Tid
	a.fieldMap["cover"] = a.Cover
	a.fieldMap["ctime"] = a.Ctime
	a.fieldMap["pubdate"] = a.Pubdate
	a.fieldMap["duration"] = a.Duration
	a.fieldMap["title"] = a.Title
	a.fieldMap["intro"] = a.Intro
	a.fieldMap["upper_mid"] = a.UpperMid
	a.fieldMap["upper_name"] = a.UpperName
	a.fieldMap["face_name"] = a.FaceName
	a.fieldMap["stat_view"] = a.StatView
	a.fieldMap["stat_danmaku"] = a.StatDanmaku
	a.fieldMap["stat_reply"] = a.StatReply
	a.fieldMap["stat_favorite"] = a.StatFavorite
	a.fieldMap["stat_coin"] = a.StatCoin
	a.fieldMap["stat_share"] = a.StatShare
	a.fieldMap["stat_like"] = a.StatLike
	a.fieldMap["stat_dislike"] = a.StatDislike
	a.fieldMap["stat_now_rank"] = a.StatNowRank
	a.fieldMap["stat_his_rank"] = a.StatHisRank
	a.fieldMap["stat_evaluation"] = a.StatEvaluation
	a.fieldMap["stat_vt"] = a.StatVt
	a.fieldMap["honor_reply"] = a.HonorReply
	a.fieldMap["resp"] = a.Resp
}

func (a archivedVideo) clone(db *gorm.DB) archivedVideo {
	a.archivedVideoDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a archivedVideo) replaceDB(db *gorm.DB) archivedVideo {
	a.archivedVideoDo.ReplaceDB(db)
	return a
}

type archivedVideoDo struct{ gen.DO }

type IArchivedVideoDo interface {
	gen.SubQuery
	Debug() IArchivedVideoDo
	WithContext(ctx context.Context) IArchivedVideoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IArchivedVideoDo
	WriteDB() IArchivedVideoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IArchivedVideoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IArchivedVideoDo
	Not(conds ...gen.Condition) IArchivedVideoDo
	Or(conds ...gen.Condition) IArchivedVideoDo
	Select(conds ...field.Expr) IArchivedVideoDo
	Where(conds ...gen.Condition) IArchivedVideoDo
	Order(conds ...field.Expr) IArchivedVideoDo
	Distinct(cols ...field.Expr) IArchivedVideoDo
	Omit(cols ...field.Expr) IArchivedVideoDo
	Join(table schema.Tabler, on ...field.Expr) IArchivedVideoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IArchivedVideoDo
	RightJoin(table schema.Tabler, on ...field.Expr) IArchivedVideoDo
	Group(cols ...field.Expr) IArchivedVideoDo
	Having(conds ...gen.Condition) IArchivedVideoDo
	Limit(limit int) IArchivedVideoDo
	Offset(offset int) IArchivedVideoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IArchivedVideoDo
	Unscoped() IArchivedVideoDo
	Create(values ...*model.ArchivedVideo) error
	CreateInBatches(values []*model.ArchivedVideo, batchSize int) error
	Save(values ...*model.ArchivedVideo) error
	First() (*model.ArchivedVideo, error)
	Take() (*model.ArchivedVideo, error)
	Last() (*model.ArchivedVideo, error)
	Find() ([]*model.ArchivedVideo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ArchivedVideo, err error)
	FindInBatches(result *[]*model.ArchivedVideo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ArchivedVideo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IArchivedVideoDo
	Assign(attrs ...field.AssignExpr) IArchivedVideoDo
	Joins(fields ...field.RelationField) IArchivedVideoDo
	Preload(fields ...field.RelationField) IArchivedVideoDo
	FirstOrInit() (*model.ArchivedVideo, error)
	FirstOrCreate() (*model.ArchivedVideo, error)
	FindByPage(offset int, limit int) (result []*model.ArchivedVideo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IArchivedVideoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a archivedVideoDo) Debug() IArchivedVideoDo {
	return a.withDO(a.DO.Debug())
}

func (a archivedVideoDo) WithContext(ctx context.Context) IArchivedVideoDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a archivedVideoDo) ReadDB() IArchivedVideoDo {
	return a.Clauses(dbresolver.Read)
}

func (a archivedVideoDo) WriteDB() IArchivedVideoDo {
	return a.Clauses(dbresolver.Write)
}

func (a archivedVideoDo) Session(config *gorm.Session) IArchivedVideoDo {
	return a.withDO(a.DO.Session(config))
}

func (a archivedVideoDo) Clauses(conds ...clause.Expression) IArchivedVideoDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a archivedVideoDo) Returning(value interface{}, columns ...string) IArchivedVideoDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a archivedVideoDo) Not(conds ...gen.Condition) IArchivedVideoDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a archivedVideoDo) Or(conds ...gen.Condition) IArchivedVideoDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a archivedVideoDo) Select(conds ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a archivedVideoDo) Where(conds ...gen.Condition) IArchivedVideoDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a archivedVideoDo) Order(conds ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a archivedVideoDo) Distinct(cols ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a archivedVideoDo) Omit(cols ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a archivedVideoDo) Join(table schema.Tabler, on ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a archivedVideoDo) LeftJoin(table schema.Tabler, on ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a archivedVideoDo) RightJoin(table schema.Tabler, on ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a archivedVideoDo) Group(cols ...field.Expr) IArchivedVideoDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a archivedVideoDo) Having(conds ...gen.Condition) IArchivedVideoDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a archivedVideoDo) Limit(limit int) IArchivedVideoDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a archivedVideoDo) Offset(offset int) IArchivedVideoDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a archivedVideoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IArchivedVideoDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a archivedVideoDo) Unscoped() IArchivedVideoDo {
	return a.withDO(a.DO.Unscoped())
}

func (a archivedVideoDo) Create(values ...*model.ArchivedVideo) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a archivedVideoDo) CreateInBatches(values []*model.ArchivedVideo, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a archivedVideoDo) Save(values ...*model.ArchivedVideo) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a archivedVideoDo) First() (*model.ArchivedVideo, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedVideo), nil
	}
}

func (a archivedVideoDo) Take() (*model.ArchivedVideo, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedVideo), nil
	}
}

func (a archivedVideoDo) Last() (*model.ArchivedVideo, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedVideo), nil
	}
}

func (a archivedVideoDo) Find() ([]*model.ArchivedVideo, error) {
	result, err := a.DO.Find()
	return result.([]*model.ArchivedVideo), err
}

func (a archivedVideoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ArchivedVideo, err error) {
	buf := make([]*model.ArchivedVideo, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a archivedVideoDo) FindInBatches(result *[]*model.ArchivedVideo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a archivedVideoDo) Attrs(attrs ...field.AssignExpr) IArchivedVideoDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a archivedVideoDo) Assign(attrs ...field.AssignExpr) IArchivedVideoDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a archivedVideoDo) Joins(fields ...field.RelationField) IArchivedVideoDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a archivedVideoDo) Preload(fields ...field.RelationField) IArchivedVideoDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a archivedVideoDo) FirstOrInit() (*model.ArchivedVideo, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedVideo), nil
	}
}

func (a archivedVideoDo) FirstOrCreate() (*model.ArchivedVideo, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedVideo), nil
	}
}

func (a archivedVideoDo) FindByPage(offset int, limit int) (result []*model.ArchivedVideo, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a archivedVideoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a archivedVideoDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a archivedVideoDo) Delete(models ...*model.ArchivedVideo) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *archivedVideoDo) withDO(do gen.Dao) *archivedVideoDo {
	a.DO = *do.(*gen.DO)
	return a
}
