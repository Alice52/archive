// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/alice52/archive/bili/source/gen/model"
)

func newArchivedFav(db *gorm.DB, opts ...gen.DOOption) archivedFav {
	_archivedFav := archivedFav{}

	_archivedFav.archivedFavDo.UseDB(db, opts...)
	_archivedFav.archivedFavDo.UseModel(&model.ArchivedFav{})

	tableName := _archivedFav.archivedFavDo.TableName()
	_archivedFav.ALL = field.NewAsterisk(tableName)
	_archivedFav.ID = field.NewInt64(tableName, "id")
	_archivedFav.CreateTime = field.NewTime(tableName, "create_time")
	_archivedFav.UpdateTime = field.NewTime(tableName, "update_time")
	_archivedFav.DeleteTime = field.NewField(tableName, "delete_time")
	_archivedFav.Fid = field.NewString(tableName, "fid")
	_archivedFav.Vid = field.NewString(tableName, "vid")
	_archivedFav.Cover = field.NewString(tableName, "cover")
	_archivedFav.Duration = field.NewInt64(tableName, "duration")
	_archivedFav.FavTime = field.NewInt64(tableName, "fav_time")
	_archivedFav.Intro = field.NewString(tableName, "intro")
	_archivedFav.Title = field.NewString(tableName, "title")
	_archivedFav.Type = field.NewString(tableName, "type")
	_archivedFav.Season = field.NewString(tableName, "season")
	_archivedFav.UpperMid = field.NewString(tableName, "upper_mid")
	_archivedFav.CntInfo = field.NewString(tableName, "cnt_info")
	_archivedFav.FavFolder = archivedFavHasOneFavFolder{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("FavFolder", "model.ArchivedFavFolder"),
	}

	_archivedFav.fillFieldMap()

	return _archivedFav
}

// archivedFav 收藏视频
type archivedFav struct {
	archivedFavDo

	ALL        field.Asterisk
	ID         field.Int64
	CreateTime field.Time
	UpdateTime field.Time
	DeleteTime field.Field
	Fid        field.String // bili folder
	Vid        field.String // bili avid
	Cover      field.String // video cover
	Duration   field.Int64  // video duration
	FavTime    field.Int64  // video favor time
	Intro      field.String // video intro
	Title      field.String // video title
	Type       field.String // video type
	Season     field.String // video season
	UpperMid   field.String // {"mid": 173986740, "name": "这个月-"}
	CntInfo    field.String // {"collect": 73600, "play": 1068474, "danmaku": 2632, "vt": 0, "play_switch": 0, "reply": 0, "view_text_1": "106.8万" }
	FavFolder  archivedFavHasOneFavFolder

	fieldMap map[string]field.Expr
}

func (a archivedFav) Table(newTableName string) *archivedFav {
	a.archivedFavDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a archivedFav) As(alias string) *archivedFav {
	a.archivedFavDo.DO = *(a.archivedFavDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *archivedFav) updateTableName(table string) *archivedFav {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.CreateTime = field.NewTime(table, "create_time")
	a.UpdateTime = field.NewTime(table, "update_time")
	a.DeleteTime = field.NewField(table, "delete_time")
	a.Fid = field.NewString(table, "fid")
	a.Vid = field.NewString(table, "vid")
	a.Cover = field.NewString(table, "cover")
	a.Duration = field.NewInt64(table, "duration")
	a.FavTime = field.NewInt64(table, "fav_time")
	a.Intro = field.NewString(table, "intro")
	a.Title = field.NewString(table, "title")
	a.Type = field.NewString(table, "type")
	a.Season = field.NewString(table, "season")
	a.UpperMid = field.NewString(table, "upper_mid")
	a.CntInfo = field.NewString(table, "cnt_info")

	a.fillFieldMap()

	return a
}

func (a *archivedFav) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *archivedFav) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 16)
	a.fieldMap["id"] = a.ID
	a.fieldMap["create_time"] = a.CreateTime
	a.fieldMap["update_time"] = a.UpdateTime
	a.fieldMap["delete_time"] = a.DeleteTime
	a.fieldMap["fid"] = a.Fid
	a.fieldMap["vid"] = a.Vid
	a.fieldMap["cover"] = a.Cover
	a.fieldMap["duration"] = a.Duration
	a.fieldMap["fav_time"] = a.FavTime
	a.fieldMap["intro"] = a.Intro
	a.fieldMap["title"] = a.Title
	a.fieldMap["type"] = a.Type
	a.fieldMap["season"] = a.Season
	a.fieldMap["upper_mid"] = a.UpperMid
	a.fieldMap["cnt_info"] = a.CntInfo

}

func (a archivedFav) clone(db *gorm.DB) archivedFav {
	a.archivedFavDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a archivedFav) replaceDB(db *gorm.DB) archivedFav {
	a.archivedFavDo.ReplaceDB(db)
	return a
}

type archivedFavHasOneFavFolder struct {
	db *gorm.DB

	field.RelationField
}

func (a archivedFavHasOneFavFolder) Where(conds ...field.Expr) *archivedFavHasOneFavFolder {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a archivedFavHasOneFavFolder) WithContext(ctx context.Context) *archivedFavHasOneFavFolder {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a archivedFavHasOneFavFolder) Session(session *gorm.Session) *archivedFavHasOneFavFolder {
	a.db = a.db.Session(session)
	return &a
}

func (a archivedFavHasOneFavFolder) Model(m *model.ArchivedFav) *archivedFavHasOneFavFolderTx {
	return &archivedFavHasOneFavFolderTx{a.db.Model(m).Association(a.Name())}
}

type archivedFavHasOneFavFolderTx struct{ tx *gorm.Association }

func (a archivedFavHasOneFavFolderTx) Find() (result *model.ArchivedFavFolder, err error) {
	return result, a.tx.Find(&result)
}

func (a archivedFavHasOneFavFolderTx) Append(values ...*model.ArchivedFavFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a archivedFavHasOneFavFolderTx) Replace(values ...*model.ArchivedFavFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a archivedFavHasOneFavFolderTx) Delete(values ...*model.ArchivedFavFolder) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a archivedFavHasOneFavFolderTx) Clear() error {
	return a.tx.Clear()
}

func (a archivedFavHasOneFavFolderTx) Count() int64 {
	return a.tx.Count()
}

type archivedFavDo struct{ gen.DO }

type IArchivedFavDo interface {
	gen.SubQuery
	Debug() IArchivedFavDo
	WithContext(ctx context.Context) IArchivedFavDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IArchivedFavDo
	WriteDB() IArchivedFavDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IArchivedFavDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IArchivedFavDo
	Not(conds ...gen.Condition) IArchivedFavDo
	Or(conds ...gen.Condition) IArchivedFavDo
	Select(conds ...field.Expr) IArchivedFavDo
	Where(conds ...gen.Condition) IArchivedFavDo
	Order(conds ...field.Expr) IArchivedFavDo
	Distinct(cols ...field.Expr) IArchivedFavDo
	Omit(cols ...field.Expr) IArchivedFavDo
	Join(table schema.Tabler, on ...field.Expr) IArchivedFavDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IArchivedFavDo
	RightJoin(table schema.Tabler, on ...field.Expr) IArchivedFavDo
	Group(cols ...field.Expr) IArchivedFavDo
	Having(conds ...gen.Condition) IArchivedFavDo
	Limit(limit int) IArchivedFavDo
	Offset(offset int) IArchivedFavDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IArchivedFavDo
	Unscoped() IArchivedFavDo
	Create(values ...*model.ArchivedFav) error
	CreateInBatches(values []*model.ArchivedFav, batchSize int) error
	Save(values ...*model.ArchivedFav) error
	First() (*model.ArchivedFav, error)
	Take() (*model.ArchivedFav, error)
	Last() (*model.ArchivedFav, error)
	Find() ([]*model.ArchivedFav, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ArchivedFav, err error)
	FindInBatches(result *[]*model.ArchivedFav, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ArchivedFav) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IArchivedFavDo
	Assign(attrs ...field.AssignExpr) IArchivedFavDo
	Joins(fields ...field.RelationField) IArchivedFavDo
	Preload(fields ...field.RelationField) IArchivedFavDo
	FirstOrInit() (*model.ArchivedFav, error)
	FirstOrCreate() (*model.ArchivedFav, error)
	FindByPage(offset int, limit int) (result []*model.ArchivedFav, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IArchivedFavDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a archivedFavDo) Debug() IArchivedFavDo {
	return a.withDO(a.DO.Debug())
}

func (a archivedFavDo) WithContext(ctx context.Context) IArchivedFavDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a archivedFavDo) ReadDB() IArchivedFavDo {
	return a.Clauses(dbresolver.Read)
}

func (a archivedFavDo) WriteDB() IArchivedFavDo {
	return a.Clauses(dbresolver.Write)
}

func (a archivedFavDo) Session(config *gorm.Session) IArchivedFavDo {
	return a.withDO(a.DO.Session(config))
}

func (a archivedFavDo) Clauses(conds ...clause.Expression) IArchivedFavDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a archivedFavDo) Returning(value interface{}, columns ...string) IArchivedFavDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a archivedFavDo) Not(conds ...gen.Condition) IArchivedFavDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a archivedFavDo) Or(conds ...gen.Condition) IArchivedFavDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a archivedFavDo) Select(conds ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a archivedFavDo) Where(conds ...gen.Condition) IArchivedFavDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a archivedFavDo) Order(conds ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a archivedFavDo) Distinct(cols ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a archivedFavDo) Omit(cols ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a archivedFavDo) Join(table schema.Tabler, on ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a archivedFavDo) LeftJoin(table schema.Tabler, on ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a archivedFavDo) RightJoin(table schema.Tabler, on ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a archivedFavDo) Group(cols ...field.Expr) IArchivedFavDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a archivedFavDo) Having(conds ...gen.Condition) IArchivedFavDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a archivedFavDo) Limit(limit int) IArchivedFavDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a archivedFavDo) Offset(offset int) IArchivedFavDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a archivedFavDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IArchivedFavDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a archivedFavDo) Unscoped() IArchivedFavDo {
	return a.withDO(a.DO.Unscoped())
}

func (a archivedFavDo) Create(values ...*model.ArchivedFav) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a archivedFavDo) CreateInBatches(values []*model.ArchivedFav, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a archivedFavDo) Save(values ...*model.ArchivedFav) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a archivedFavDo) First() (*model.ArchivedFav, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedFav), nil
	}
}

func (a archivedFavDo) Take() (*model.ArchivedFav, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedFav), nil
	}
}

func (a archivedFavDo) Last() (*model.ArchivedFav, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedFav), nil
	}
}

func (a archivedFavDo) Find() ([]*model.ArchivedFav, error) {
	result, err := a.DO.Find()
	return result.([]*model.ArchivedFav), err
}

func (a archivedFavDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ArchivedFav, err error) {
	buf := make([]*model.ArchivedFav, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a archivedFavDo) FindInBatches(result *[]*model.ArchivedFav, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a archivedFavDo) Attrs(attrs ...field.AssignExpr) IArchivedFavDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a archivedFavDo) Assign(attrs ...field.AssignExpr) IArchivedFavDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a archivedFavDo) Joins(fields ...field.RelationField) IArchivedFavDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a archivedFavDo) Preload(fields ...field.RelationField) IArchivedFavDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a archivedFavDo) FirstOrInit() (*model.ArchivedFav, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedFav), nil
	}
}

func (a archivedFavDo) FirstOrCreate() (*model.ArchivedFav, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedFav), nil
	}
}

func (a archivedFavDo) FindByPage(offset int, limit int) (result []*model.ArchivedFav, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a archivedFavDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a archivedFavDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a archivedFavDo) Delete(models ...*model.ArchivedFav) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *archivedFavDo) withDO(do gen.Dao) *archivedFavDo {
	a.DO = *do.(*gen.DO)
	return a
}
