// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/alice52/archive/bili/source/gen/model"
)

func newArchivedSeason(db *gorm.DB, opts ...gen.DOOption) archivedSeason {
	_archivedSeason := archivedSeason{}

	_archivedSeason.archivedSeasonDo.UseDB(db, opts...)
	_archivedSeason.archivedSeasonDo.UseModel(&model.ArchivedSeason{})

	tableName := _archivedSeason.archivedSeasonDo.TableName()
	_archivedSeason.ALL = field.NewAsterisk(tableName)
	_archivedSeason.SeasonID = field.NewInt64(tableName, "season_id")
	_archivedSeason.CreateTime = field.NewTime(tableName, "create_time")
	_archivedSeason.UpdateTime = field.NewTime(tableName, "update_time")
	_archivedSeason.DeleteTime = field.NewField(tableName, "delete_time")
	_archivedSeason.Cover = field.NewString(tableName, "cover")
	_archivedSeason.Title = field.NewString(tableName, "title")
	_archivedSeason.Intro = field.NewString(tableName, "intro")
	_archivedSeason.EpisodesCount = field.NewInt64(tableName, "episodes_count")
	_archivedSeason.Link = field.NewString(tableName, "link")
	_archivedSeason.MediaID = field.NewInt64(tableName, "media_id")
	_archivedSeason.Ctime = field.NewInt64(tableName, "ctime")
	_archivedSeason.Pubdate = field.NewInt64(tableName, "pubdate")
	_archivedSeason.RatingCount = field.NewInt64(tableName, "rating_count")
	_archivedSeason.RatingScore = field.NewFloat64(tableName, "rating_score")
	_archivedSeason.StatView = field.NewInt64(tableName, "stat_view")
	_archivedSeason.StatDanmaku = field.NewInt64(tableName, "stat_danmaku")
	_archivedSeason.StatReply = field.NewInt64(tableName, "stat_reply")
	_archivedSeason.StatFavorite = field.NewInt64(tableName, "stat_favorite")
	_archivedSeason.StatCoin = field.NewInt64(tableName, "stat_coin")
	_archivedSeason.StatShare = field.NewInt64(tableName, "stat_share")
	_archivedSeason.StatLike = field.NewInt64(tableName, "stat_like")
	_archivedSeason.StatDislike = field.NewInt64(tableName, "stat_dislike")
	_archivedSeason.StatNowRank = field.NewInt64(tableName, "stat_now_rank")
	_archivedSeason.StatHisRank = field.NewInt64(tableName, "stat_his_rank")
	_archivedSeason.StatEvaluation = field.NewString(tableName, "stat_evaluation")
	_archivedSeason.StatVt = field.NewInt64(tableName, "stat_vt")
	_archivedSeason.Styles = field.NewString(tableName, "styles")
	_archivedSeason.UpperMid = field.NewInt64(tableName, "upper_mid")
	_archivedSeason.UpperName = field.NewString(tableName, "upper_name")
	_archivedSeason.FaceName = field.NewString(tableName, "face_name")
	_archivedSeason.Resp = field.NewString(tableName, "resp")

	_archivedSeason.fillFieldMap()

	return _archivedSeason
}

// archivedSeason 视频信息
type archivedSeason struct {
	archivedSeasonDo

	ALL            field.Asterisk
	SeasonID       field.Int64
	CreateTime     field.Time
	UpdateTime     field.Time
	DeleteTime     field.Field
	Cover          field.String  // season cover
	Title          field.String  // season title
	Intro          field.String  // season evaluate
	EpisodesCount  field.Int64   // season episodes count
	Link           field.String  // season link
	MediaID        field.Int64   // season media id
	Ctime          field.Int64   // video create time
	Pubdate        field.Int64   // video publish time
	RatingCount    field.Int64   // video rating count
	RatingScore    field.Float64 // video rating score
	StatView       field.Int64   // video view count
	StatDanmaku    field.Int64   // video danmaku count
	StatReply      field.Int64   // video reply count
	StatFavorite   field.Int64   // video favorite count
	StatCoin       field.Int64   // video coin count
	StatShare      field.Int64   // video share count
	StatLike       field.Int64   // video like count
	StatDislike    field.Int64   // video dislike count
	StatNowRank    field.Int64   // video now rank
	StatHisRank    field.Int64   // video history rank
	StatEvaluation field.String  // video evaluation
	StatVt         field.Int64   // video vt
	Styles         field.String  // video styles
	UpperMid       field.Int64   // video upper mid
	UpperName      field.String  // video upper name
	FaceName       field.String  // video upper face
	Resp           field.String

	fieldMap map[string]field.Expr
}

func (a archivedSeason) Table(newTableName string) *archivedSeason {
	a.archivedSeasonDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a archivedSeason) As(alias string) *archivedSeason {
	a.archivedSeasonDo.DO = *(a.archivedSeasonDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *archivedSeason) updateTableName(table string) *archivedSeason {
	a.ALL = field.NewAsterisk(table)
	a.SeasonID = field.NewInt64(table, "season_id")
	a.CreateTime = field.NewTime(table, "create_time")
	a.UpdateTime = field.NewTime(table, "update_time")
	a.DeleteTime = field.NewField(table, "delete_time")
	a.Cover = field.NewString(table, "cover")
	a.Title = field.NewString(table, "title")
	a.Intro = field.NewString(table, "intro")
	a.EpisodesCount = field.NewInt64(table, "episodes_count")
	a.Link = field.NewString(table, "link")
	a.MediaID = field.NewInt64(table, "media_id")
	a.Ctime = field.NewInt64(table, "ctime")
	a.Pubdate = field.NewInt64(table, "pubdate")
	a.RatingCount = field.NewInt64(table, "rating_count")
	a.RatingScore = field.NewFloat64(table, "rating_score")
	a.StatView = field.NewInt64(table, "stat_view")
	a.StatDanmaku = field.NewInt64(table, "stat_danmaku")
	a.StatReply = field.NewInt64(table, "stat_reply")
	a.StatFavorite = field.NewInt64(table, "stat_favorite")
	a.StatCoin = field.NewInt64(table, "stat_coin")
	a.StatShare = field.NewInt64(table, "stat_share")
	a.StatLike = field.NewInt64(table, "stat_like")
	a.StatDislike = field.NewInt64(table, "stat_dislike")
	a.StatNowRank = field.NewInt64(table, "stat_now_rank")
	a.StatHisRank = field.NewInt64(table, "stat_his_rank")
	a.StatEvaluation = field.NewString(table, "stat_evaluation")
	a.StatVt = field.NewInt64(table, "stat_vt")
	a.Styles = field.NewString(table, "styles")
	a.UpperMid = field.NewInt64(table, "upper_mid")
	a.UpperName = field.NewString(table, "upper_name")
	a.FaceName = field.NewString(table, "face_name")
	a.Resp = field.NewString(table, "resp")

	a.fillFieldMap()

	return a
}

func (a *archivedSeason) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *archivedSeason) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 31)
	a.fieldMap["season_id"] = a.SeasonID
	a.fieldMap["create_time"] = a.CreateTime
	a.fieldMap["update_time"] = a.UpdateTime
	a.fieldMap["delete_time"] = a.DeleteTime
	a.fieldMap["cover"] = a.Cover
	a.fieldMap["title"] = a.Title
	a.fieldMap["intro"] = a.Intro
	a.fieldMap["episodes_count"] = a.EpisodesCount
	a.fieldMap["link"] = a.Link
	a.fieldMap["media_id"] = a.MediaID
	a.fieldMap["ctime"] = a.Ctime
	a.fieldMap["pubdate"] = a.Pubdate
	a.fieldMap["rating_count"] = a.RatingCount
	a.fieldMap["rating_score"] = a.RatingScore
	a.fieldMap["stat_view"] = a.StatView
	a.fieldMap["stat_danmaku"] = a.StatDanmaku
	a.fieldMap["stat_reply"] = a.StatReply
	a.fieldMap["stat_favorite"] = a.StatFavorite
	a.fieldMap["stat_coin"] = a.StatCoin
	a.fieldMap["stat_share"] = a.StatShare
	a.fieldMap["stat_like"] = a.StatLike
	a.fieldMap["stat_dislike"] = a.StatDislike
	a.fieldMap["stat_now_rank"] = a.StatNowRank
	a.fieldMap["stat_his_rank"] = a.StatHisRank
	a.fieldMap["stat_evaluation"] = a.StatEvaluation
	a.fieldMap["stat_vt"] = a.StatVt
	a.fieldMap["styles"] = a.Styles
	a.fieldMap["upper_mid"] = a.UpperMid
	a.fieldMap["upper_name"] = a.UpperName
	a.fieldMap["face_name"] = a.FaceName
	a.fieldMap["resp"] = a.Resp
}

func (a archivedSeason) clone(db *gorm.DB) archivedSeason {
	a.archivedSeasonDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a archivedSeason) replaceDB(db *gorm.DB) archivedSeason {
	a.archivedSeasonDo.ReplaceDB(db)
	return a
}

type archivedSeasonDo struct{ gen.DO }

type IArchivedSeasonDo interface {
	gen.SubQuery
	Debug() IArchivedSeasonDo
	WithContext(ctx context.Context) IArchivedSeasonDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IArchivedSeasonDo
	WriteDB() IArchivedSeasonDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IArchivedSeasonDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IArchivedSeasonDo
	Not(conds ...gen.Condition) IArchivedSeasonDo
	Or(conds ...gen.Condition) IArchivedSeasonDo
	Select(conds ...field.Expr) IArchivedSeasonDo
	Where(conds ...gen.Condition) IArchivedSeasonDo
	Order(conds ...field.Expr) IArchivedSeasonDo
	Distinct(cols ...field.Expr) IArchivedSeasonDo
	Omit(cols ...field.Expr) IArchivedSeasonDo
	Join(table schema.Tabler, on ...field.Expr) IArchivedSeasonDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IArchivedSeasonDo
	RightJoin(table schema.Tabler, on ...field.Expr) IArchivedSeasonDo
	Group(cols ...field.Expr) IArchivedSeasonDo
	Having(conds ...gen.Condition) IArchivedSeasonDo
	Limit(limit int) IArchivedSeasonDo
	Offset(offset int) IArchivedSeasonDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IArchivedSeasonDo
	Unscoped() IArchivedSeasonDo
	Create(values ...*model.ArchivedSeason) error
	CreateInBatches(values []*model.ArchivedSeason, batchSize int) error
	Save(values ...*model.ArchivedSeason) error
	First() (*model.ArchivedSeason, error)
	Take() (*model.ArchivedSeason, error)
	Last() (*model.ArchivedSeason, error)
	Find() ([]*model.ArchivedSeason, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ArchivedSeason, err error)
	FindInBatches(result *[]*model.ArchivedSeason, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ArchivedSeason) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IArchivedSeasonDo
	Assign(attrs ...field.AssignExpr) IArchivedSeasonDo
	Joins(fields ...field.RelationField) IArchivedSeasonDo
	Preload(fields ...field.RelationField) IArchivedSeasonDo
	FirstOrInit() (*model.ArchivedSeason, error)
	FirstOrCreate() (*model.ArchivedSeason, error)
	FindByPage(offset int, limit int) (result []*model.ArchivedSeason, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IArchivedSeasonDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a archivedSeasonDo) Debug() IArchivedSeasonDo {
	return a.withDO(a.DO.Debug())
}

func (a archivedSeasonDo) WithContext(ctx context.Context) IArchivedSeasonDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a archivedSeasonDo) ReadDB() IArchivedSeasonDo {
	return a.Clauses(dbresolver.Read)
}

func (a archivedSeasonDo) WriteDB() IArchivedSeasonDo {
	return a.Clauses(dbresolver.Write)
}

func (a archivedSeasonDo) Session(config *gorm.Session) IArchivedSeasonDo {
	return a.withDO(a.DO.Session(config))
}

func (a archivedSeasonDo) Clauses(conds ...clause.Expression) IArchivedSeasonDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a archivedSeasonDo) Returning(value interface{}, columns ...string) IArchivedSeasonDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a archivedSeasonDo) Not(conds ...gen.Condition) IArchivedSeasonDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a archivedSeasonDo) Or(conds ...gen.Condition) IArchivedSeasonDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a archivedSeasonDo) Select(conds ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a archivedSeasonDo) Where(conds ...gen.Condition) IArchivedSeasonDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a archivedSeasonDo) Order(conds ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a archivedSeasonDo) Distinct(cols ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a archivedSeasonDo) Omit(cols ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a archivedSeasonDo) Join(table schema.Tabler, on ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a archivedSeasonDo) LeftJoin(table schema.Tabler, on ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a archivedSeasonDo) RightJoin(table schema.Tabler, on ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a archivedSeasonDo) Group(cols ...field.Expr) IArchivedSeasonDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a archivedSeasonDo) Having(conds ...gen.Condition) IArchivedSeasonDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a archivedSeasonDo) Limit(limit int) IArchivedSeasonDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a archivedSeasonDo) Offset(offset int) IArchivedSeasonDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a archivedSeasonDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IArchivedSeasonDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a archivedSeasonDo) Unscoped() IArchivedSeasonDo {
	return a.withDO(a.DO.Unscoped())
}

func (a archivedSeasonDo) Create(values ...*model.ArchivedSeason) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a archivedSeasonDo) CreateInBatches(values []*model.ArchivedSeason, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a archivedSeasonDo) Save(values ...*model.ArchivedSeason) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a archivedSeasonDo) First() (*model.ArchivedSeason, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedSeason), nil
	}
}

func (a archivedSeasonDo) Take() (*model.ArchivedSeason, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedSeason), nil
	}
}

func (a archivedSeasonDo) Last() (*model.ArchivedSeason, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedSeason), nil
	}
}

func (a archivedSeasonDo) Find() ([]*model.ArchivedSeason, error) {
	result, err := a.DO.Find()
	return result.([]*model.ArchivedSeason), err
}

func (a archivedSeasonDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ArchivedSeason, err error) {
	buf := make([]*model.ArchivedSeason, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a archivedSeasonDo) FindInBatches(result *[]*model.ArchivedSeason, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a archivedSeasonDo) Attrs(attrs ...field.AssignExpr) IArchivedSeasonDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a archivedSeasonDo) Assign(attrs ...field.AssignExpr) IArchivedSeasonDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a archivedSeasonDo) Joins(fields ...field.RelationField) IArchivedSeasonDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a archivedSeasonDo) Preload(fields ...field.RelationField) IArchivedSeasonDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a archivedSeasonDo) FirstOrInit() (*model.ArchivedSeason, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedSeason), nil
	}
}

func (a archivedSeasonDo) FirstOrCreate() (*model.ArchivedSeason, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ArchivedSeason), nil
	}
}

func (a archivedSeasonDo) FindByPage(offset int, limit int) (result []*model.ArchivedSeason, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a archivedSeasonDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a archivedSeasonDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a archivedSeasonDo) Delete(models ...*model.ArchivedSeason) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *archivedSeasonDo) withDO(do gen.Dao) *archivedSeasonDo {
	a.DO = *do.(*gen.DO)
	return a
}
